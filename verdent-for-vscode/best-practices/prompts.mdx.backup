---
title: Prompt Engineering
description: Best practices for writing effective prompts
---

---

Effective prompts are the foundation of successful AI-assisted development. Clear, specific requests with appropriate context enable Verdent to deliver accurate, relevant results.

### What You'll Learn

- Best practices for writing effective prompts
- How to provide context and avoid common mistakes
- Advanced techniques like @-mentions and subagent delegation
- Examples of well-structured prompts
- Iterative refinement strategies

---

## What Makes an Effective Prompt

Effective prompts are clear, specific, and provide necessary context for Verdent to understand your intent and deliver accurate results.

### Be Specific About What You Want

Instead of vague requests, specify exactly what you need:

**Bad:**
```
Fix the code
```

**Good:**
```
Add input validation to the email field in ContactForm.js to reject invalid email formats
```

### Include Implementation Details

Provide technical specifications when you have preferences:

```
Use React hooks with useState and useEffect
```

```
Implement with async/await instead of promises
```

```
Follow the existing error handling pattern in auth.js
```

### Specify Scope

Clarify which files, components, or features are involved:

```
Update only the authentication middleware, don't modify routes
```

```
Refactor the User model and its associated controllers
```

### Provide Context About Your Project

Help Verdent understand your architecture and patterns:

```
We use TypeScript with strict mode
```

```
Follow the existing naming convention in services/
```

```
Match the styling approach in other components
```

### State Expected Outcomes

Describe what success looks like:

```
Should return 400 status for invalid input
```

```
Component should render without errors
```

```
All existing tests should still pass
```

### Use Natural Language

No special syntax required - write as you would explain to a colleague:

```
Create a new API endpoint that accepts user registration data, validates the email format, checks for duplicates, and returns the created user with a 201 status
```

**Key Principles:**
- Clarity over brevity - be explicit about requirements
- Include technical details when you have preferences
- Reference existing patterns to maintain consistency
- Specify what should NOT change when relevant

---

## Common Prompting Mistakes

### Being Too Vague

**Mistake:** "Make the app better" or "Fix the bugs"

**Problem:** Verdent doesn't know what improvements you want or which bugs to address

**Solution:** Specify exactly what needs improvement or which bug to fix

### Omitting Important Context

**Mistake:** "Add authentication" without mentioning your tech stack

**Problem:** Verdent might implement JWT when you use OAuth, or vice versa

**Solution:** Specify implementation approach, existing patterns, and technical requirements

### Requesting Too Much at Once

**Mistake:** "Build the entire user management system with authentication, authorization, profiles, settings, and admin dashboard"

**Problem:** Complex multi-system requests are harder to execute correctly in one go

**Solution:** Break into smaller tasks - start with authentication, then authorization, then profiles

### Not Specifying Files or Scope

**Mistake:** "Update the validation logic"

**Problem:** Unclear which files or validation to modify

**Solution:** "Update validation in UserController.js to require strong passwords"

### Assuming Verdent Knows Unstated Requirements

**Mistake:** Expecting Verdent to know your specific business rules or constraints

**Problem:** Verdent implements generic solutions without your specific requirements

**Solution:** State all constraints, business rules, and requirements explicitly

### Not Using @-Mentions for Context

**Mistake:** Referencing files without including them in context

**Problem:** Verdent may not have access to files you're discussing

**Solution:** Use @filename.js to explicitly include relevant files

### Ignoring Error Messages

**Mistake:** Repeatedly asking for the same thing when Verdent encounters errors

**Problem:** Same approach yields same errors

**Solution:** Read error messages, adjust prompt based on what failed

### Not Using Plan Mode for Complex Changes

**Mistake:** Requesting large refactorings or multi-file changes without using Plan Mode first

**Problem:** You don't see the full scope until files are already modified, leading to unexpected changes

**Solution:** Switch to Plan Mode for complex tasks to review approach before execution

### Working Without Version Control

**Mistake:** Using Auto-Run or Skip Permission Mode without Git initialized

**Problem:** No safety net if Verdent makes unwanted changes - files can be modified or deleted without recovery option

**Solution:** Always have Git initialized and committed before using permissive modes

### Not Asking Verdent to Interview You

**Mistake:** Providing incomplete requirements and expecting Verdent to guess correctly

**Problem:** Verdent implements based on assumptions that may not match your needs

**Solution:** Ask Verdent to interview you with clarifying questions, especially in Plan Mode: "Ask me clarifying questions about the requirements before creating the plan"

---

## Well-Structured Prompt Examples

<Tabs>
  <Tab title="Feature Implementation">
    Creating new functionality with clear requirements and constraints:

    ```
    Create a POST /api/tasks endpoint that:
    - Accepts task title (required), description (optional), and category_id (required)
    - Validates that the category exists in the database
    - Returns 400 if validation fails with descriptive error messages
    - Saves the task to the database and returns the created task with 201 status
    - Add this to the existing tasks router in routes/tasks.js
    - Create the controller method in controllers/taskController.js
    - Use the existing error handling pattern from other controllers
    ```

    **What makes this effective:**
    - Clear requirements for inputs and validation
    - Specific file locations for implementation
    - Reference to existing patterns to maintain consistency
    - Expected HTTP status codes and error handling
  </Tab>

  <Tab title="Bug Fix">
    Describing issues with context and proposed solutions:

    ```
    Fix the race condition in payment processing at checkout. When multiple users submit payments simultaneously, some transactions fail with "duplicate order ID" errors. The issue appears to be in PaymentController.js around line 45 where we generate order IDs. Implement proper locking or use UUID generation to ensure unique IDs even under concurrent load.
    ```

    **What makes this effective:**
    - Clear problem description with symptoms
    - Specific location of issue (file and line number)
    - Context about when it happens (concurrent users)
    - Suggested solution approaches
  </Tab>

  <Tab title="Refactoring">
    Changing implementation while preserving behavior:

    ```
    Refactor the authentication middleware in middleware/auth.js to use JWT tokens instead of session cookies. Keep the same authorization logic, but:
    - Replace session validation with JWT verification
    - Store tokens in httpOnly cookies
    - Maintain the existing user object structure that routes expect
    - Update only the authentication mechanism, don't change authorization rules
    - Ensure all existing routes continue to work without modification
    ```

    **What makes this effective:**
    - Clear goal (JWT instead of sessions)
    - Specific file to refactor
    - Explicit constraints (what should NOT change)
    - Backward compatibility requirement
  </Tab>

  <Tab title="Testing">
    Writing tests with comprehensive coverage:

    ```
    Write comprehensive unit tests for the UserService class in services/UserService.js. Cover:
    - User creation with valid and invalid data
    - Email validation edge cases (empty, malformed, duplicate)
    - Password hashing verification
    - User lookup by ID and email
    - Error handling for database failures
    Use Jest and follow the testing patterns in existing service tests
    ```

    **What makes this effective:**
    - Specific class/file to test
    - Complete list of scenarios to cover
    - Testing framework specified
    - Reference to existing test patterns
  </Tab>

  <Tab title="Component Creation">
    Building UI components with detailed specifications:

    ```
    Create a reusable SearchBar component for the product catalog with:
    - Text input with real-time debounced search (300ms delay)
    - Category dropdown filter (fetch options from /api/categories)
    - Price range slider (min $0, max $1000)
    - Clear filters button
    - Use Material-UI components to match existing design
    - Emit search parameters via onChange callback to parent
    - Include PropTypes for all props
    ```

    **What makes this effective:**
    - Complete feature list with specific details
    - Technical specs (300ms debounce, price range)
    - UI library specified (Material-UI)
    - Integration approach (callback to parent)
  </Tab>
</Tabs>

**Common Patterns in Effective Prompts:**
- Clear, specific requirements
- Technical details about implementation
- References to existing code and patterns
- Expected behavior and edge cases
- Scope boundaries (what should/shouldn't change)

---

## Advanced Prompting Techniques

### Using @-Mentions for Precise Context

Reference specific files, components, or subagents:

```
@auth.js @UserController.js Refactor authentication to use the same validation pattern
```

**Benefits:** Ensures Verdent has exact context, prevents ambiguity about which files to modify

### Plan Mode for Complex Tasks

Switch to Plan Mode before execution for large changes:

```
Switch to Plan Mode
Refactor the entire API layer to use TypeScript with strict type checking
```

**Benefits:** Review approach, ask clarifying questions, understand scope before committing

### Subagent Delegation

Delegate specialized tasks to built-in or custom subagents for parallel execution:

```
@Code-reviewer Review the security vulnerabilities in authentication flow
@Explorer Find all files that import the deprecated API client
@Verifier Validate the authentication logic in the middleware
```

**Benefits:** Leverage specialized agents, parallel task execution, focused expertise

**Built-in Default Subagents:**
- `@Verifier` - Quick code checks and validation
- `@Explorer` - Fast codebase exploration and file finding
- `@Code-reviewer` - Code quality assessment for security, maintainability, and performance

### Think Hard Mode for Complex Problems

Enable extended reasoning for sophisticated challenges:

```
Think: Design the optimal database schema for a multi-tenant SaaS application with complex permissions and role hierarchies
```

**Benefits:** Deeper analysis, multiple approach evaluation, better solutions for complex problems

### Iterative Refinement

Build on previous responses with progressive refinement:

```
Initial: "Create a dashboard component"
Follow-up: "Add real-time data updates using WebSockets"
Follow-up: "Now add filtering and sorting capabilities"
```

**Benefits:** Incremental development, test each step, adjust based on results

### Constraint-Based Prompting

Specify what NOT to change alongside what to change:

```
Add caching to the API endpoints, but:
- Don't modify the authentication middleware
- Keep the existing error handling unchanged
- Maintain backward compatibility with mobile clients
```

**Benefits:** Prevents unintended changes, maintains stability in critical areas

### Reference Existing Patterns

Point to existing code as implementation examples:

```
Implement the new ProductService following the same pattern as UserService.js, including error handling, validation, and database transaction management
```

**Benefits:** Maintains consistency, leverages proven patterns, reduces explanation needed

### Using todos.md for Multi-Step Planning

Create a todos.md file to track complex, multi-step tasks:

```
Create a todos.md file with these tasks:
1. Refactor authentication to use JWT tokens
2. Update all controllers to use new auth middleware
3. Add tests for authentication flow
4. Update API documentation

Review and refine this plan before we start implementing.
```

**Benefits:** Clear roadmap, review plan multiple times before execution, track progress across sessions

### Clearing Context Between Tasks

Start new sessions between different todos for fresh context:

```
After completing todo #1: "Start a new session"
Then: "Let's work on todo #2 from todos.md - Update all controllers to use new auth middleware"
```

**Benefits:** Prevents context contamination, ensures Verdent focuses on current task without baggage from previous work, reduces token usage

### MCP Server Integration

Use MCP (Model Context Protocol) servers to inject specialized context:
- Project-specific documentation
- API specifications (OpenAPI, GraphQL schemas)
- Framework-specific knowledge

**Benefits:** Enhanced understanding of custom frameworks, internal tools, specialized domains

---

## Including Context in Prompts

### @-Mentions for Files

Explicitly include relevant files in context:

```
@models/User.js @controllers/UserController.js Add password reset functionality
```

**When to use:** When you need Verdent to reference specific files

### Describe Project Architecture

Include high-level context about your stack:

```
This is a MERN stack application (MongoDB, Express, React, Node.js) with JWT authentication. Add role-based access control following our existing middleware pattern.
```

**When to use:** For new features that need to integrate with existing architecture

### Reference Existing Patterns

Point to code that demonstrates your conventions:

```
Follow the same error handling pattern used in ProductController.js - return consistent error objects with status codes and descriptive messages
```

**When to use:** To maintain consistency with established patterns

### Specify Technical Constraints

State limitations or requirements:

```
We're using TypeScript with strict mode enabled, React 18 with hooks only (no class components), and Material-UI v5 for styling
```

**When to use:** When technical choices are constrained

### Provide Business Logic Context

Explain domain-specific rules:

```
Users can only view tasks assigned to them or their team. Managers can view all tasks in their department. Admins can view everything.
```

**When to use:** When business rules affect implementation

### Include Error Context

Share error messages or logs when debugging:

```
Getting "TypeError: Cannot read property 'id' of undefined" at UserController.js:42 when trying to update user profiles. The req.user object exists but doesn't have an id property after the recent auth middleware changes.
```

**When to use:** For debugging and fixing errors

### Automatic Context Loading

Verdent automatically loads relevant files based on your request. You can rely on this for:
- Files mentioned by name in prompts
- Related files in the same directory
- Commonly accessed project files

### Use Project and User Rules

Configure persistent context through rules files (Settings â†’ Rules):

**User Rules (user_rules.md):**
Global preferences applied across all projects - coding style, preferred libraries, personal conventions

**Project Rules (AGENTS.md):**
Project-specific standards - architectural patterns, coding standards, development workflows

```
Example: Define in AGENTS.md that your project uses TypeScript strict mode, follows Airbnb style guide, and requires tests for all new features
```

**Plan Rules (plan_rules.md):**
Customize plan format and content in Plan Mode

**Benefits:** Persistent context without repeating in every prompt, consistent behavior across sessions

### Provide Images for Visual Context

Include screenshots, mockups, or diagrams:

```
@screenshot.png Implement this UI design with React components
```

**Benefits:** Visual specifications more accurate than text descriptions, especially for UI/UX work

### Share Website Links with Ultrathink

Reference external documentation or examples:

```
Ultrathink: Read this API documentation at https://api-docs.example.com/v1/endpoints and implement the authentication flow
```

**Benefits:** Verdent fetches and analyzes web content for accurate implementation based on official docs

---

## Iterative Refinement Strategies

### Start Broad, Then Add Specificity

**Initial prompt:**
```
Add authentication to the API
```

Verdent's response might be generic. Refine:

```
Use JWT tokens stored in httpOnly cookies, implement refresh token rotation, and follow the authentication pattern from our existing UserController
```

### Review Output and Provide Corrections

If Verdent's implementation doesn't match expectations:

```
The validation logic is good, but use Joi schema validation instead of manual checks. Match the validation pattern in ProductController.js
```

### Use Follow-Up Prompts in Same Session

Build incrementally:

```
Initial: "Create a UserProfile component"
Follow-up: "Add an avatar upload feature with image preview"
Follow-up: "Add validation - max 5MB, only jpg/png formats"
Follow-up: "Show upload progress with a progress bar"
```

### Ask for Explanations When Unclear

If implementation seems unexpected:

```
Why did you use Redux instead of Context API? Can you explain the trade-offs for this use case?
```

Then refine based on understanding:

```
Actually, use Context API for consistency with the rest of our application
```

### Leverage Plan Mode for Major Refinements

For complex changes:

```
Switch to Plan Mode
Show me how you would refactor the authentication system to support OAuth providers
```

Review the plan, ask questions, iterate on the approach before execution.

### Provide Examples of Desired Output

If Verdent's style doesn't match yours:

```
The component structure is close, but use this pattern instead:
[paste example of your preferred structure]
Apply this same pattern to the remaining components
```

### Clarify Constraints After Seeing Issues

If output violates unstated constraints:

```
Good approach, but don't modify the database schema - work within the existing User table structure
```

### Progressive Enhancement

Start with core functionality, add features iteratively:

```
Step 1: "Create basic CRUD endpoints for tasks"
Step 2: "Add pagination to the GET endpoint"
Step 3: "Add filtering by status and priority"
Step 4: "Add full-text search across title and description"
```

---

## See Also

<CardGroup cols={3}>
  <Card title="Context Management" href="/verdent-for-vscode/best-practices/context" icon="layer-group">
    Managing context windows and optimization strategies
  </Card>
  <Card title="Execution Modes" href="/verdent-for-vscode/execution-resources/overview" icon="toggle-on">
    Understanding execution modes for different scenarios
  </Card>
  <Card title="Error Handling" href="/verdent-for-vscode/best-practices/errors" icon="triangle-exclamation">
    Handling errors and troubleshooting issues
  </Card>
</CardGroup>
